name: Endurance Test

on:
  schedule:
    - cron: '0 22 * * *'  # 毎日22:00にプロセスを開始します
  workflow_dispatch:
    inputs:
      yaml_file:
        description: '読み込むYAMLファイルの名前 (拡張子なし)'
        required: true
        default: 'weekdays'
      build_or_publish:
        description: 'ビルドまたは公開 (build または publish)'
        required: true
        type: choice
        options:
          - 'build'
          - 'publish'
        default: 'build'

env:
  test_dir: "C:/Hutzper/self_host_runner"
  repository_url: "https://github.com/Hutzper-inc/CSharp.Hutzper.Library.git"
  mekiki_project: "C:/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/Hutzper.Project.Mekiki.csproj"
  yaml_settings_dir: "C:/CSharp.Hutzper.Library/test_endurance/settings"
  log_dir: "C:/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/bin/x64/log"
  base_results_dir: "C:/CSharp.Hutzper.Library/test_endurance/result"

jobs:
  set_timestamp:
    runs-on: [self-hosted, windows]
    outputs:
      timestamp: ${{ steps.get_timestamp.outputs.timestamp }}
      date_suffix: ${{ steps.get_date_suffix.outputs.date_suffix }}
    steps:
      - name: Get Current Timestamp
        id: get_timestamp
        run: |
          $timestamp = (Get-Date -Format "yyyyMMdd-HHmmss")
          echo "::set-output name=timestamp::$timestamp"
        shell: powershell

      - name: Get Date Suffix
        id: get_date_suffix
        run: |
          $dateSuffix = (Get-Date -Format "yyyyMMdd")
          echo "::set-output name=date_suffix::$dateSuffix"
        shell: powershell

  endurance_test_mekiki:
    runs-on: [self-hosted, windows]
    needs: set_timestamp
    env:
      timestamp: ${{ needs.set_timestamp.outputs.timestamp }}
      date_suffix: ${{ needs.set_timestamp.outputs.date_suffix }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref_name }}

      - name: Prepare Mekiki Directory
        run: |
          $branch = '${{ github.ref_name }}'

          if ($branch -eq 'main') {
            $branch = 'develop'
          }

          if (-Not (Test-Path "${{ env.test_dir }}")) {
            git clone ${{ env.repository_url }} ${{ env.test_dir }}
          } else {
            Set-Location -Path ${{ env.test_dir }}
            git fetch origin
            git checkout $branch
            git pull origin $branch
          }
        shell: powershell

      - name: Build or Publish Project
        run: |
          $operation = '${{ github.event.inputs.build_or_publish }}'
          if ([string]::IsNullOrEmpty($operation)) {
            $operation = 'build'
          }

          if ($operation -eq 'build') {
            dotnet build ${{ env.mekiki_project }} -c Release
          } elseif ($operation -eq 'publish') {
            dotnet publish ${{ env.mekiki_project }} -c Release -o "${{ env.test_dir }}/publish"
          } else {
            Write-Error "無効なオプションが指定されました。'build' または 'publish' を指定してください。"
            exit 1
          }
        shell: powershell

      - name: Install PowerShell-Yaml Module
        run: |
          Install-Module -Name powershell-yaml -Scope CurrentUser -Force
        shell: powershell

      - name: Read YAML File and Run Process Tests
        run: |
          $yamlFileName = '${{ github.event.inputs.yaml_file }}.yml'
          $yamlFilePath = "${{ env.yaml_settings_dir }}\$yamlFileName"
          
          if (-Not (Test-Path $yamlFilePath)) {
            Write-Error "YAMLファイル '$yamlFilePath' が存在しません。"
            exit 1
          }

          $yamlContent = Get-Content $yamlFilePath | Out-String
          $processSettings = $yamlContent | ConvertFrom-Yaml

          Write-Output "Starting Mekiki application..."
          Start-Process -FilePath "dotnet" -ArgumentList "run --project `"$($env:mekiki_project)`"" -NoNewWindow -PassThru | Out-Null
          Start-Sleep -Seconds 5

          Write-Output "Checking if Mekiki process is alive..."
          $processName = "Hutzper.Project.Mekiki"
          $startTime = Get-Date
          $endTime = $startTime.AddMinutes(1)

          while ((Get-Date) -lt $endTime) {
            $process = Get-Process -Name $processName -ErrorAction SilentlyContinue

            if ($process) {
              Write-Output "$processName is running."
              break
            }
            Start-Sleep -Seconds 5
          }

          if (-Not $process) {
            Write-Output "$processName has stopped within the 1-minute check period."
            exit 1
          }

          # 日付ごとのフォルダを作成
          $dateFolder = "${{ env.base_results_dir }}/$($env.date_suffix)"
          if (-Not (Test-Path $dateFolder)) {
            New-Item -Path $dateFolder -ItemType Directory | Out-Null
          }

          # 動作テスト
          $logFilePath = "${{ env.log_dir }}/${{ env.date_suffix }}.log"
          $timestamp = '${{ env.timestamp }}'
          $resultsFilePath = "${dateFolder}\test_results_$timestamp.txt"
          $logResultsFilePath = "${dateFolder}\log_results_$timestamp.txt"

          $results = @()
          $logResults = @()
          foreach ($tests in $processSettings.tests) {
            Write-Output "プロセス: $($tests.name)"
            Write-Output "テスト時間: $($tests.duration_minutes) 分"
            $startTime = Get-Date
            $endTime = $startTime.AddMinutes($tests.duration_minutes)

            Write-Output "プロセス $($tests.name) のテストを開始します"
            $processStopped = $false
            while ((Get-Date) -lt $endTime) {
              Start-Sleep -Seconds 5

              $logContent = Get-Content $logFilePath -Raw
              Write-Output "Current log content:"
              Write-Output $logContent

              $logLines = $logContent -split "`n"
              $filteredLines = @()
              foreach ($line in $logLines) {
                if ($line -match "^\d{2}:\d{2}:\d{2}\.\d{3}") {
                  $lineTimestamp = $matches[0]
                  $lineTime = [datetime]::ParseExact($lineTimestamp, "HH:mm:ss.fff", $null)

                  if ($lineTime -gt [datetime]::ParseExact($timestamp, "yyyyMMdd-HHmmss", $null)) {
                    $filteredLines += $line
                  }
                }
              }

              Write-Output "Filtered log content:"
              $filteredLines | ForEach-Object { Write-Output $_ }

              $logResults += $filteredLines

              $deadTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              if ($filteredLines -match "異常") {
                Write-Output "$($deadTime): プロセス $($tests.name) が異常を検知しました"
                $errorLines = $filteredLines | Select-String "異常" | ForEach-Object { $_.Line }
                $results += $errorLines
                $processStopped = $true
                break
              } else {
                Write-Output "$($deadTime): プロセス $($tests.name) は動作しています"
              }
            }
            if (-Not $processStopped) {
              Write-Output "プロセス $($tests.name) のテストが成功しました"
              $results += "$($tests.name): Success"
            } else {
              Write-Output "プロセス $($tests.name) のテストが失敗しました"
              $results += "$($tests.name): Failure"
              $results | Out-File -FilePath $resultsFilePath -Append
              Write-Output "結果が 'test_results_$($timestamp).txt' に保存されました"
              $logResults | Out-File -FilePath $logResultsFilePath -Append
              Write-Output "ログが 'log_results_$($timestamp).txt' に保存されました"
              exit 1
            }
          }

        shell: powershell
