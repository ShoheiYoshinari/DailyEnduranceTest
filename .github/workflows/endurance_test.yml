name: Endurance Test

on:
  schedule:
    - cron: '0 22 * * *'  # 毎日22:00にプロセスを開始します
  workflow_dispatch:
    inputs:
      zip_file:
        description: '読み込むYAMLファイルの名前 (拡張子なし)'
        required: false
        default: 'weekdays'
      build_or_publish:
        description: 'ビルドまたは公開 (build または publish)'
        required: false
        type: choice
        options:
          - 'build'
          - 'publish'
        default: 'build'

env:
  test_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library"
  repository_url: "https://github.com/Hutzper-inc/CSharp.Hutzper.Library.git"
  mekiki_project: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/Hutzper.Project.Mekiki.csproj"
  test_settings_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/test_endurance/settings"
  mekiki_setting: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/bin/x64"
  log_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/bin/x64/log"
  test_results_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/test_endurance/result"
  vs_path: "C:/Program Files/Microsoft Visual Studio/2022/Community/Common7/IDE/devenv.exe"

jobs:
  endurance_test_mekiki:
    runs-on: [self-hosted, windows]
    steps:
      - name: Get Current Timestamp and Date Suffix
        id: get_timestamp_and_suffix
        run: |
          $timestamp = (Get-Date -Format "yyyyMMdd-HHmmss")
          $dateSuffix = (Get-Date -Format "yyyyMMdd")
          echo "::set-output name=timestamp::$timestamp"
          echo "::set-output name=date_suffix::$dateSuffix"
        shell: powershell

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref_name }}

      - name: Prepare Mekiki Branch
        run: |
          $branch = '${{ github.ref_name }}'
          if ($branch -eq 'main') {
            $branch = 'test_endurance'
          }

          if (-Not (Test-Path "${{ env.test_dir }}")) {
            git clone ${{ env.repository_url }} ${{ env.test_dir }}
          } else {
            Set-Location -Path ${{ env.test_dir }}
            git fetch origin
            git checkout $branch
            git pull origin $branch
          }
        shell: powershell

      - name: Dotnet Build or Publish 
        run: |
          $operation = '${{ github.event.inputs.build_or_publish }}' -or 'build'

          if ($operation -eq 'build') {
            dotnet build ${{ env.mekiki_project }} -c Release
          } elseif ($operation -eq 'publish') {
            dotnet publish ${{ env.mekiki_project }} -c Release -o "${{ env.test_dir }}/publish"
          } else {
            Write-Error "無効なオプションが指定されました。'build' または 'publish' を指定してください。"
            exit 1
          }
        shell: powershell

      - name: Install PowerShell-Yaml Module
        run: |
          Install-Module -Name powershell-yaml -Scope CurrentUser -Force -AllowClobber
        shell: powershell

      - name: Read YAML File and Run Tests
        run: |
          $timestamp = '${{ steps.get_timestamp_and_suffix.outputs.timestamp }}'
          $date_suffix = '${{ steps.get_timestamp_and_suffix.outputs.date_suffix }}'
          $yamlFileInput = '${{ github.event.inputs.zip_file }}' -or 'weekdays'
          $yamlFileName = "$yamlFileInput.yml"
          $yamlFilePath = "${{ env.test_settings_dir }}\$yamlFileName"

          if (-Not (Test-Path $yamlFilePath)) {
            Write-Error "YAMLファイル '$yamlFilePath' が存在しません。"
            exit 1
          }

          $yamlContent = Get-Content $yamlFilePath | Out-String
          $processSettings = $yamlContent | ConvertFrom-Yaml

          # 日付ごとのフォルダを作成
          $dateFolder = "${{ env.test_results_dir }}/$date_suffix"
          if (-Not (Test-Path $dateFolder)) {
            New-Item -Path $dateFolder -ItemType Directory | Out-Null
          }

          # 動作テストのために各テストごとにプロセスを起動
          $results = @()
          foreach ($test in $processSettings.tests) {
            $zipFileInput = '${{ github.event.inputs.zip_file }}' -or 'weekdays'
            $zipFileName = "$zipFileInput.zip"
            $zipFilePath = "${{ env.test_settings_dir }}\$zipFileName"

            if (-Not (Test-Path $zipFilePath)) {
              Write-Error "ZIPファイル '$zipFilePath' が存在しません。"
              exit 1
            }

            # ZIPファイルを展開してx64に上書き
            Remove-Item "${{ env.mekiki_setting }}" -Recurse -Force
            Expand-Archive -Path $zipFilePath -DestinationPath ${{ env.mekiki_setting }} -Force

            Write-Output "Starting Mekiki application for test: $($test.name)..."
            if (-Not (Test-Path "${{ env.vs_path }}")) {
              Write-Error "Visual Studio のパスが見つかりません。"
              exit 1
            }
            Start-Process -FilePath "${{ env.vs_path }}" -ArgumentList "`"$($env:mekiki_project)`" /Run" -NoNewWindow -PassThru | Out-Null
            Start-Sleep -Seconds 5

            Write-Output "Checking if Mekiki process is alive..."
            $processName = "Hutzper.Project.Mekiki"
            $startTime = Get-Date
            $endTime = $startTime.AddMinutes(1)

            while ((Get-Date) -lt $endTime) {
              if (Get-Process -Name $processName -ErrorAction SilentlyContinue) {
                Write-Output "$processName is running."
                break
              }
              Start-Sleep -Seconds 5
            }

            if (-Not (Get-Process -Name $processName -ErrorAction SilentlyContinue)) {
              Write-Output "$processName has stopped within the 1-minute check period."
              exit 1
            }

            # 動作テスト
            $logFilePath = "${{ env.log_dir }}/$date_suffix.log"
            $resultsFilePath = "${dateFolder}/test_results_$timestamp.txt"
            $logResultsFilePath = "${dateFolder}/log_results_$timestamp.txt"

            $endTime = (Get-Date).AddMinutes($test.duration_minutes)

            Write-Output "プロセス $($test.name) のテストを開始します"
            while ((Get-Date) -lt $endTime) {
              Start-Sleep -Seconds 5

              $logContent = Get-Content $logFilePath -Raw
              $filteredLines = $logContent -split "`n" | Where-Object { $_ -match "異常" }

              if ($filteredLines) {
                Write-Output "異常を検知しました: $($filteredLines -join ", ")"
                $results += "$($test.name): Failure"
                $filteredLines | Out-File -FilePath $resultsFilePath -Append
                Write-Host "::error::$($test.name)テスト中に異常が発生しました"
                exit 1  # 非ゼロ終了コードを返してGitHub Actionsにエラー通知
              } else {
                Write-Output "$($test.name)は動作しています"
              }
            }

            $results += "$($test.name): Success"
          }

          # 結果をファイルに保存
          $results | Out-File -FilePath $resultsFilePath -Append
          Write-Output "結果が 'test_results_$($timestamp).txt' に保存されました"
        shell: powershell
