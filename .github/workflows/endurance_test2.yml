name: Endurance Test v2

on:
  schedule:
    - cron: '0 22 * * *'
  workflow_dispatch:
    inputs:
      yaml_file:
        description: '読み込むYAMLファイルの名前 (拡張子なし)'
        required: false
        default: 'weekdays'
      build_or_publish:
        description: 'ビルドまたは公開 (build または publish)'
        required: false
        type: choice
        options:
          - 'build'
          - 'publish'
        default: 'build'

env:
  test_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library"
  repository_url: "https://github.com/Hutzper-inc/CSharp.Hutzper.Library.git"
  mekiki_project: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/Hutzper.Project.Mekiki.csproj"
  yaml_settings_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/test_endurance/settings"
  log_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/Hutzper.Library.FormsMekiki/bin/x64/log"
  base_results_dir: "C:/Hutzper/self_host_runner/CSharp.Hutzper.Library/test_endurance/result"
  vs_path: "C:/Program Files/Microsoft Visual Studio/2022/Community/Common7/IDE/devenv.exe"

jobs:
  endurance_test_mekiki:
    runs-on: [self-hosted, windows]
    steps:
      - name: Get Current Timestamp and Date Suffix
        id: get_timestamp_and_suffix
        run: |
          function Get-Timestamp {
            (Get-Date -Format "yyyyMMdd-HHmmss")
          }
          function Get-DateSuffix {
            (Get-Date -Format "yyyyMMdd")
          }
          $timestamp = Get-Timestamp
          $dateSuffix = Get-DateSuffix
          echo "::set-output name=timestamp::$timestamp"
          echo "::set-output name=date_suffix::$dateSuffix"
        shell: powershell

      - name: Checkout Repository and Prepare Branch
        run: |
          function Prepare-Repository {
            param ($repoUrl, $dir, $branch)
            if (-Not (Test-Path $dir)) {
              git clone $repoUrl $dir
            } else {
              Set-Location -Path $dir
              git fetch origin
              git checkout $branch
              git pull origin $branch
            }
          }

          $branch = '${{ github.ref_name }}'
          if ($branch -eq 'main') {
            $branch = 'test_endurance'
          }

          Prepare-Repository -repoUrl "${{ env.repository_url }}" -dir "${{ env.test_dir }}" -branch $branch
        shell: powershell

      - name: Build or Publish Mekiki Project
        run: |
          function Build-Or-Publish {
            param ($operation, $projectPath, $outputDir)
            if ($operation -eq 'build') {
              dotnet build $projectPath -c Release
            } elseif ($operation -eq 'publish') {
              dotnet publish $projectPath -c Release -o $outputDir
            } else {
              throw "無効なオプションが指定されました。'build' または 'publish' を指定してください。"
            }
          }

          $operation = '${{ github.event.inputs.build_or_publish }}'
          if (-Not $operation) {
            $operation = 'build'
          }

          Build-Or-Publish -operation $operation -projectPath "${{ env.mekiki_project }}" -outputDir "${{ env.test_dir }}/publish"
        shell: powershell

      - name: Install PowerShell-Yaml Module
        run: |
          Install-Module -Name powershell-yaml -Scope CurrentUser -Force
        shell: powershell

      - name: Read YAML File and Start Mekiki Tests
        run: |
          function Read-YamlFile {
            param ($yamlFilePath)
            $yamlContent = Get-Content $yamlFilePath | Out-String
            $yamlContent | ConvertFrom-Yaml
          }

          function Check-Process {
            param ($processName)
            $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
            return $process -ne $null
          }

          function Test-Process {
            param ($processSettings, $logFilePath, $resultsFilePath, $logResultsFilePath, $timestamp)
            $results = @()
            $logResults = @()
            foreach ($test in $processSettings.tests) {
              Write-Output "プロセス: $($test.name)"
              Write-Output "テスト時間: $($test.duration_minutes) 分"
              $startTime = Get-Date
              $endTime = $startTime.AddMinutes($test.duration_minutes)

              Write-Output "プロセス $($test.name) のテストを開始します"
              $processStopped = $false
              while ((Get-Date) -lt $endTime) {
                Start-Sleep -Seconds 5

                $logContent = Get-Content $logFilePath -Raw
                $logLines = $logContent -split "`n"
                $filteredLines = @()
                foreach ($line in $logLines) {
                  if ($line -match "^\d{2}:\d{2}:\d{2}\.\d{3}") {
                    $lineTimestamp = $matches[0]
                    $lineTime = [datetime]::ParseExact($lineTimestamp, "HH:mm:ss.fff", $null)

                    if ($lineTime -gt [datetime]::ParseExact($timestamp, "yyyyMMdd-HHmmss", $null)) {
                      $filteredLines += $line
                    }
                  }
                }
                $logResults = $filteredLines

                $deadTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                if ($filteredLines -match "異常") {
                  Write-Output "$($deadTime): $($test.name)テスト中に異常を検知しました"
                  $errorLines = $filteredLines | Select-String "異常" | ForEach-Object { $_.Line }
                  $results += "$($test.name): Failure"
                  $errorLines | Out-File -FilePath $resultsFilePath -Append
                  $logResults | Out-File -FilePath $logResultsFilePath -Append
                  Write-Output "結果が 'test_results_$($timestamp).txt' に保存されました"
                  Write-Output "ログが 'log_results_$($timestamp).txt' に保存されました"
                  $processStopped = $true
                  break
                } else {
                  Write-Output "$($deadTime): $($test.name)は動作しています"
                }
              }
              if (-Not $processStopped) {
                Write-Output "$($test.name) のテストが成功しました"
                $results += "$($test.name): Success"
              }
            }
            $results | Out-File -FilePath $resultsFilePath -Append
            Write-Output "結果が 'test_results_$($timestamp).txt' に保存されました"
            $logResults | Out-File -FilePath $logResultsFilePath -Append
            Write-Output "ログが 'log_results_$($timestamp).txt' に保存されました"
          }

          # YAMLファイルの読み込み
          $yamlFileInput = '${{ github.event.inputs.yaml_file }}'
          if (-Not $yamlFileInput) {
            $yamlFileInput = 'weekdays'
          }
          $yamlFilePath = "${{ env.yaml_settings_dir }}/$yamlFileInput.yml"
          if (-Not (Test-Path $yamlFilePath)) {
            throw "YAMLファイル '$yamlFilePath' が存在しません。"
          }

          $processSettings = Read-YamlFile -yamlFilePath $yamlFilePath

          Write-Output "Starting Mekiki application..."
          if (-Not (Test-Path "${{ env.vs_path }}")) {
            Write-Error "Visual Studio のパスが見つかりません。"
            exit 1
          }
          Start-Process -FilePath "${{ env.vs_path }}" -ArgumentList "`"$($env:mekiki_project)`" /Run" -NoNewWindow -PassThru | Out-Null
          Start-Sleep -Seconds 5

          Write-Output "Checking if Mekiki process is alive..."
          $processName = "Hutzper.Project.Mekiki"
          $startTime = Get-Date
          $endTime = $startTime.AddMinutes(1)

          while ((Get-Date) -lt $endTime) {
            $process = Get-Process -Name $processName -ErrorAction SilentlyContinue

            if ($process) {
              Write-Output "$processName is running."
              break
            }
            Start-Sleep -Seconds 5
          }

          if (-Not $process) {
            Write-Output "$processName has stopped within the 1-minute check period."
            exit 1
          }

          # 日付ごとのフォルダを作成
          $dateSuffix = '${{ steps.get_timestamp_and_suffix.outputs.date_suffix }}'
          $dateFolder = "${{ env.base_results_dir }}/$dateSuffix"
          if (-Not (Test-Path $dateFolder)) {
            New-Item -Path $dateFolder -ItemType Directory | Out-Null
          }

          $resultsFilePath = "${dateFolder}/test_results_${{ steps.get_timestamp_and_suffix.outputs.timestamp }}.txt"
          $logResultsFilePath = "${dateFolder}/log_results_${{ steps.get_timestamp_and_suffix.outputs.timestamp }}.txt"

          Test-Process -processSettings $processSettings -logFilePath "${{ env.log_dir }}/$dateSuffix.log" -resultsFilePath $resultsFilePath -logResultsFilePath $logResultsFilePath -timestamp "${{ steps.get_timestamp_and_suffix.outputs.timestamp }}"
        shell: powershell
